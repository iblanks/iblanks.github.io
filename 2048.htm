<!DOCTYPE html>
<html>
<head>
<meta http-equiv=Content-Type content="text/html;charset=utf8">
<title>机器人乐园(985969852) - 2048交互</title>
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0, maximum-scale=1, user-scalable=no, minimal-ui">
</head>
<body>
<link rel="stylesheet" type="text/css" href="2048.css" />
<!-- <style>*</style> -->
<div class="container">
	<div class="heading">
	<h1 class="title">2048</h1>
	<div class="scores-container">
		<div class="score-container">0</div>
		<div class="best-container">0</div>
	</div>
	</div>
	<div class="above-game">
	<p class="game-intro">WSAD 或 方向键移动</p>
	<input id="step" class="restart-button" onClick="copy()" value="复制步骤">
	
	</div>
	<div class="game-container">
	<div class="game-message">
		<p></p>
		<div class="lower">
		<a class="keep-playing-button">继续</a>
		<a class="retry-button">再来一次</a>
		</div>
	</div>

	<div class="grid-container">
		<div class="grid-row">
		<div class="grid-cell"></div>
		<div class="grid-cell"></div>
		<div class="grid-cell"></div>
		<div class="grid-cell"></div>
		</div>
		<div class="grid-row">
		<div class="grid-cell"></div>
		<div class="grid-cell"></div>
		<div class="grid-cell"></div>
		<div class="grid-cell"></div>
		</div>
		<div class="grid-row">
		<div class="grid-cell"></div>
		<div class="grid-cell"></div>
		<div class="grid-cell"></div>
		<div class="grid-cell"></div>
		</div>
		<div class="grid-row">
		<div class="grid-cell"></div>
		<div class="grid-cell"></div>
		<div class="grid-cell"></div>
		<div class="grid-cell"></div>
		</div>
	</div>
	<div class="tile-container">
	</div>
	</div>
</div>
<script>
function copy() {
	document.getElementById("step").value = localStorage.step;
	document.getElementById("step").select(); // 选择对象
	document.execCommand("Copy"); // 执行浏览器复制命令
	document.getElementById("step").value = "导出步骤";
	alert("导出成功，请到AI群粘贴。");
}

(function() {
	var lastTime = 0;
	var vendors = ['webkit', 'moz'];
	for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
		window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
		window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];
	}

	if (!window.requestAnimationFrame) {
		window.requestAnimationFrame = function(callback) {
			var currTime = new Date().getTime();
			var timeToCall = Math.max(0, 16 - (currTime - lastTime));
			var id = window.setTimeout(function() {
				callback(currTime + timeToCall);
			},
			timeToCall);
			lastTime = currTime + timeToCall;
			return id;
		};
	}

	if (!window.cancelAnimationFrame) {
		window.cancelAnimationFrame = function(id) {
			clearTimeout(id);
		};
	}
} ());

// 等到浏览器准备好渲染游戏(避免故障)
window.requestAnimationFrame(function() {
	new GameManager(4, KeyboardInputManager, HTMLActuator, LocalStorageManager);

	var storage = new LocalStorageManager;
	var noticeClose = document.querySelector(".notice-close-button");
	var notice = document.querySelector(".app-notice");
	if (storage.getNoticeClosed()) {
		notice.parentNode.removeChild(notice);
	} else {
		<!-- noticeClose.addEventListener("click", -->
		<!-- function() { -->
			<!-- notice.parentNode.removeChild(notice); -->
			<!-- storage.setNoticeClosed(true); -->
			<!-- //ga("send", "event", "notice", "closed"); -->
		<!-- }); -->
	}
});

Function.prototype.bind = Function.prototype.bind ||
function(target) {
	var self = this;
	return function(args) {
		if (! (args instanceof Array)) {
			args = [args];
		}
		self.apply(target, args);
	};
};

(function() {
	if (typeof window.Element === "undefined" || "classList" in document.documentElement) {
		return;
	}

	var prototype = Array.prototype,
	push = prototype.push,
	splice = prototype.splice,
	join = prototype.join;

	function DOMTokenList(el) {
		this.el = el;
		// 类名需要在空格上进行裁剪和拆分，以检索类列表。
		var classes = el.className.replace(/^s+|s+$/g, '').split(/s+/);
		for (var i = 0; i < classes.length; i++) {
			push.call(this, classes[i]);
		}
	}

	DOMTokenList.prototype = {
		add: function(token) {
			if (this.contains(token)) return;
			push.call(this, token);
			this.el.className = this.toString();
		},
		contains: function(token) {
			return this.el.className.indexOf(token) != -1;
		},
		item: function(index) {
			return this[index] || null;
		},
		remove: function(token) {
			if (!this.contains(token)) return;
			for (var i = 0; i < this.length; i++) {
				if (this[i] == token) break;
			}
			splice.call(this, i, 1);
			this.el.className = this.toString();
		},
		toString: function() {
			return join.call(this, ' ');
		},
		toggle: function(token) {
			if (!this.contains(token)) {
				this.add(token);
			} else {
				this.remove(token);
			}
			return this.contains(token);
		}
	};

	window.DOMTokenList = DOMTokenList;

	function defineElementGetter(obj, prop, getter) {
		if (Object.defineProperty) {
			Object.defineProperty(obj, prop, {
				get: getter
			});
		} else {
			obj.__defineGetter__(prop, getter);
		}
	}

	defineElementGetter(HTMLElement.prototype, 'classList',
	function() {
		return new DOMTokenList(this);
	});
})();

function GameManager(size, InputManager, Actuator, StorageManager) {
	this.size = size; // 网格的大小
	this.inputManager = new InputManager;
	this.storageManager = new StorageManager;
	this.actuator = new Actuator;
	this.startTiles = 2;
	this.inputManager.on("move", this.move.bind(this));
	this.inputManager.on("restart", this.restart.bind(this));
	this.inputManager.on("keepPlaying", this.keepPlaying.bind(this));
	this.setup();
}

// 重新游戏
GameManager.prototype.restart = function() {
	this.storageManager.clearGameState();
	this.actuator.continueGame();
	this.setup();
};

// 获胜后继续玩(允许超过2048)
GameManager.prototype.keepPlaying = function() {
	this.keepPlaying = true;
	this.actuator.continueGame(); // 清除游戏赢/输信息
};

// 如果游戏输了，或者赢了，并且用户没有继续玩，则返回true
GameManager.prototype.isGameTerminated = function() {
	return this.over || (this.won && !this.keepPlaying);
};

// 设置游戏
GameManager.prototype.setup = function() {
	var previousState = this.storageManager.getGameState();

	// 如果游戏存在，请从先前的游戏重新加载游戏
	if (previousState) {
		this.grid = new Grid(previousState.grid.size, previousState.grid.cells);
		this.score = previousState.score;
		this.over = previousState.over;
		this.won = previousState.won;
		this.keepPlaying = previousState.keepPlaying;
	} else {
		this.grid = new Grid(this.size);
		this.score = 0;
		localStorage.scount = 0;
		localStorage.step = "";
		this.over = false;
		this.won = false;
		this.keepPlaying = false;
		this.addStartTiles();
	}
	this.actuate();
};

// 设置开始游戏的初始方块
GameManager.prototype.addStartTiles = function() {
	for (var i = 0; i < this.startTiles; i++) {
		this.addRandomTile();
	}
};

// 在随机位置添加图块
GameManager.prototype.addRandomTile = function() {
	if (this.grid.cellsAvailable()) {
		var value = Math.random() < 0.9 ? 2 : 4;
		var tile = new Tile(this.grid.randomAvailableCell(), value);
		this.grid.insertTile(tile);
	}
};

// Sends the updated grid to the actuator
GameManager.prototype.actuate = function() {
	if (this.over) {
		// 游戏结束时清除状态(仅游戏结束，不获胜)
		//this.storageManager.clearGameState();
	} else {
		this.storageManager.setGameState(this.serialize());
	}

	this.actuator.actuate(this.grid, {
		score: this.score,
		over: this.over,
		won: this.won,
		terminated: this.isGameTerminated()
	});
};

// Represent the current game as an object
GameManager.prototype.serialize = function() {
	return {
		grid: this.grid.serialize(),
		score: this.score,
		over: this.over,
		won: this.won,
		keepPlaying: this.keepPlaying
	};
};

// 保存所有平铺位置并删除合并信息
GameManager.prototype.prepareTiles = function() {
	this.grid.eachCell(function(x, y, tile) {
		if (tile) {
			tile.mergedFrom = null;
			tile.savePosition();
		}
	});
};

Tile.prototype.savePosition = function() {
	this.previousPosition = {
		x: this.x,
		y: this.y
	};
};

// 移动图块
GameManager.prototype.moveTile = function(tile, cell) {
	this.grid.cells[tile.x][tile.y] = null;
	this.grid.cells[cell.x][cell.y] = tile;
	tile.updatePosition(cell);
};

// 沿指定方向移动网格上的方块
GameManager.prototype.move = function(direction) {
	var self = this;
	if (this.isGameTerminated()) return; // 游戏结束，直接返回
	var cell, tile;
	var vector = this.getVector(direction);
	var traversals = this.buildTraversals(vector);
	var moved = false;

	// 保存当前平铺位置并删除合并信息
	this.prepareTiles();

	// 沿着正确的方向遍历网格并移动图块
	traversals.x.forEach(function(x) {
		traversals.y.forEach(function(y) {
			cell = {
				x: x,
				y: y
			};
			tile = self.grid.cellContent(cell);

			if (tile) {
				var positions = self.findFarthestPosition(cell, vector);
				var next = self.grid.cellContent(positions.next);

				// 每行遍历 合并一次
				if (next && next.value === tile.value && !next.mergedFrom) {
					var merged = new Tile(positions.next, tile.value * 2);
					merged.mergedFrom = [tile, next];

					self.grid.insertTile(merged);
					self.grid.removeTile(tile);

					// 合并相同方块
					tile.updatePosition(positions.next);

					// 更新分数
					self.score += merged.value;

					// The mighty 2048 tile
					if (merged.value === 2048) self.won = true;
				} else {
					self.moveTile(tile, positions.farthest);
				}

				if (!self.positionsEqual(cell, tile)) {
					moved = true; // 方块从该位置移走
				}
			}
		});
	});

	if (moved) {
		var step = {
			0: "W",
			1: "D",
			2: "S",
			3: "A"
		}

		localStorage.scount = Number(localStorage.scount) + 1; //移动步数
		localStorage.step = localStorage.step + step[direction]; //移动步骤	
		this.addRandomTile();
		if (!this.movesAvailable()) {
			this.over = true; // 游戏结束
		}
		this.actuate();
	}
};

// Get the vector representing the chosen direction
GameManager.prototype.getVector = function(direction) {
	// Vectors representing tile movement
	// 0上 1右 2下 3左
	var map = {
		0 : {x: 0,y: -1},
		1 : {x: 1,y: 0},
		2 : {x: 0,y: 1},
		3 : {x: -1,y: 0}
	};
	return map[direction];
};

// 建立一个按正确顺序遍历的位置列表
GameManager.prototype.buildTraversals = function(vector) {
	var traversals = {
		x: [],
		y: []
	};

	for (var pos = 0; pos < this.size; pos++) {
		traversals.x.push(pos);
		traversals.y.push(pos);
	}

	// 总是从选定方向上最远的单元格开始遍历
	if (vector.x === 1) traversals.x = traversals.x.reverse();
	if (vector.y === 1) traversals.y = traversals.y.reverse();
	return traversals;
};

GameManager.prototype.findFarthestPosition = function(cell, vector) {
	var previous;

	// 向指定方向前进，直到发现障碍物
	do {
		previous = cell;
		cell = {
			x: previous.x + vector.x,
			y: previous.y + vector.y
		};
	} while ( this . grid . withinBounds ( cell ) && this.grid.cellAvailable(cell));

	return {
		farthest: previous,
		next: cell
	};
};

GameManager.prototype.movesAvailable = function() {
	return this.grid.cellsAvailable() || this.tileMatchesAvailable();
};

// Check for available matches between tiles (more expensive check)
GameManager.prototype.tileMatchesAvailable = function() {
	var self = this;
	var tile;
	for (var x = 0; x < this.size; x++) {
		for (var y = 0; y < this.size; y++) {
			tile = this.grid.cellContent({
				x: x,
				y: y
			});
			if (tile) {
				for (var direction = 0; direction < 4; direction++) {
					var vector = self.getVector(direction);
					var cell = {
						x: x + vector.x,
						y: y + vector.y
					};
					var other = self.grid.cellContent(cell);
					if (other && other.value === tile.value) {
						return true; // 这两个方块可以合并
					}
				}
			}
		}
	}
	return false;
};

GameManager.prototype.positionsEqual = function(first, second) {
	return first.x === second.x && first.y === second.y;
};

function Grid(size, previousState) {
	this.size = size;
	this.cells = previousState ? this.fromState(previousState) : this.empty();
}

// 构建指定大小的网格
Grid.prototype.empty = function() {
	var cells = [];
	for (var x = 0; x < this.size; x++) {
		var row = cells[x] = [];
		for (var y = 0; y < this.size; y++) {
			row.push(null);
		}
	}
	return cells;
};

Grid.prototype.fromState = function(state) {
	var cells = [];
	for (var x = 0; x < this.size; x++) {
		var row = cells[x] = [];
		for (var y = 0; y < this.size; y++) {
			var tile = state[x][y];
			row.push(tile ? new Tile(tile.position, tile.value) : null);
		}
	}
	return cells;
};

// 找到第一个可用的随机位置
Grid.prototype.randomAvailableCell = function() {
	var cells = this.availableCells();
	if (cells.length) {
		return cells[Math.floor(Math.random() * cells.length)];
	}
};

Grid.prototype.availableCells = function() {
	var cells = [];
	this.eachCell(function(x, y, tile) {
		if (!tile) {
			cells.push({
				x: x,
				y: y
			});
		}
	});
	return cells;
};

// Call callback for every cell
Grid.prototype.eachCell = function(callback) {
	for (var x = 0; x < this.size; x++) {
		for (var y = 0; y < this.size; y++) {
			callback(x, y, this.cells[x][y]);
		}
	}
};

// 检查是否有可用的单元格
Grid.prototype.cellsAvailable = function() {
	return !! this.availableCells().length;
};

// 检查指定的单元格是否被占用
Grid.prototype.cellAvailable = function(cell) {
	return ! this.cellOccupied(cell);
};

Grid.prototype.cellOccupied = function(cell) {
	return !! this.cellContent(cell);
};

Grid.prototype.cellContent = function(cell) {
	if (this.withinBounds(cell)) {
		return this.cells[cell.x][cell.y];
	} else {
		return null;
	}
};

// 在其位置插入方块
Grid.prototype.insertTile = function(tile) {
	this.cells[tile.x][tile.y] = tile;
};

Grid.prototype.removeTile = function(tile) {
	this.cells[tile.x][tile.y] = null;
};

Grid.prototype.withinBounds = function(position) {
	return position.x >= 0 && position.x < this.size && position.y >= 0 && position.y < this.size;
};

Grid.prototype.serialize = function() {
	var cellState = [];
	for (var x = 0; x < this.size; x++) {
		var row = cellState[x] = [];
		for (var y = 0; y < this.size; y++) {
			row.push(this.cells[x][y] ? this.cells[x][y].serialize() : null);
		}
	}
	return {
		size: this.size,
		cells: cellState
	};
};

function HTMLActuator() {
	this.tileContainer = document.querySelector(".tile-container");
	this.scoreContainer = document.querySelector(".score-container");
	this.scount = document.querySelector(".best-container");
	this.messageContainer = document.querySelector(".game-message");
	this.sharingContainer = document.querySelector(".score-sharing");
	this.score = 0;
	localStorage.scount = 0;
	localStorage.step = "";
}

HTMLActuator.prototype.actuate = function(grid, metadata) {
	var self = this;

	window.requestAnimationFrame(function() {
		self.clearContainer(self.tileContainer);
		grid.cells.forEach(function(column) {
			column.forEach(function(cell) {
				if (cell) {
					self.addTile(cell);
				}
			});
		});

		self.updateScore(metadata.score);

		if (metadata.terminated) {
			if (metadata.over) {
				self.message(false); // 失败
			} else if (metadata.won) {
				self.message(true); // 胜利
			}
		}
	});
};

// 继续游戏（重启并继续玩）
HTMLActuator.prototype.continueGame = function() {
	<!-- if (typeof ga !== "undefined") { -->
		<!-- ga("send", "event", "game", "restart"); -->
	<!-- } -->

	// IE only takes one value to remove at a time.
	this.messageContainer.classList.remove("game-won");
	this.messageContainer.classList.remove("game-over");
};

HTMLActuator.prototype.clearContainer = function(container) {
	while (container.firstChild) {
		container.removeChild(container.firstChild);
	}
};

HTMLActuator.prototype.addTile = function(tile) {
	var self = this;
	var wrapper = document.createElement("div");
	var inner = document.createElement("div");
	var position = tile.previousPosition || {x: tile.x,	y: tile.y};
	var positionClass = this.positionClass(position);

	// We can't use classlist because it somehow glitches when replacing classes
	var classes = ["tile", "tile-" + tile.value, positionClass];
	if (tile.value > 2048) classes.push("tile-super");
	this.applyClasses(wrapper, classes);
	inner.classList.add("tile-inner");
	inner.textContent = tile.value;
	if (tile.previousPosition) {
		// 确保首先在先前的位置渲染图块
		window.requestAnimationFrame(function() {
			classes[2] = self.positionClass({
				x: tile.x,
				y: tile.y
			});
			self.applyClasses(wrapper, classes); // Update the position
		});
	} else if (tile.mergedFrom) {
		classes.push("tile-merged");
		this.applyClasses(wrapper, classes);

		// 渲染合并的方块
		tile.mergedFrom.forEach(function(merged) {
			self.addTile(merged);
		});
	} else {
		classes.push("tile-new");
		this.applyClasses(wrapper, classes);
	}

	// Add the inner part of the tile to the wrapper
	wrapper.appendChild(inner);

	// Put the tile on the board
	this.tileContainer.appendChild(wrapper);
};

HTMLActuator.prototype.applyClasses = function(element, classes) {
	element.setAttribute("class", classes.join(" "));
};

HTMLActuator.prototype.normalizePosition = function(position) {
	return {
		x: position.x + 1,
		y: position.y + 1
	};
};

HTMLActuator.prototype.positionClass = function(position) {
	position = this.normalizePosition(position);
	return "tile-position-" + position.x + "-" + position.y;
};

HTMLActuator.prototype.updateScore = function(score) {
	this.clearContainer(this.scoreContainer);

	var difference = score - this.score;
	this.score = score;
	this.scoreContainer.textContent = this.score;

	this.scount.textContent = localStorage.scount;
	if (difference > 0) {
		var addition = document.createElement("div");
		addition.classList.add("score-addition");
		addition.textContent = "+" + difference;
		this.scoreContainer.appendChild(addition);
	}
};

HTMLActuator.prototype.message = function(won) {
	var type = won ? "game-won": "game-over";
	<!-- if (typeof ga !== "undefined") { -->
		<!-- ga("send", "event", "game", "end", type, this.score); -->
	<!-- } -->

	this.messageContainer.classList.add(type);
	this.messageContainer.getElementsByTagName("p")[0].textContent = won ? "游戏胜利!": "游戏结束!";
	this.clearContainer(this.sharingContainer);
};

function KeyboardInputManager() {
	this.events = {};

	if (window.navigator.msPointerEnabled) {
		//Internet Explorer 10 style
		this.eventTouchstart = "MSPointerDown";
		this.eventTouchmove = "MSPointerMove";
		this.eventTouchend = "MSPointerUp";
	} else {
		this.eventTouchstart = "touchstart";
		this.eventTouchmove = "touchmove";
		this.eventTouchend = "touchend";
	}
	this.listen();
}

KeyboardInputManager.prototype.on = function(event, callback) {
	if (!this.events[event]) {
		this.events[event] = [];
	}
	this.events[event].push(callback);
};

KeyboardInputManager.prototype.emit = function(event, data) {
	var callbacks = this.events[event];
	if (callbacks) {
		callbacks.forEach(function(callback) {
			callback(data);
		});
	}
};

KeyboardInputManager.prototype.listen = function() {
	var self = this;
	var map = {
		38 : 0,	// Up
		39 : 1,	// Right
		40 : 2,	// Down
		37 : 3,	// Left
		87 : 0,	// W
		68 : 1,	// D
		83 : 2, // S
		65 : 3 // A
	};

	// Respond to direction keys
	document.addEventListener("keydown",
	function(event) {
		var modifiers = event.altKey || event.ctrlKey || event.metaKey || event.shiftKey;
		var mapped = map[event.which];

		// Ignore the event if it's happening in a text field
		if (self.targetIsInput(event)) return;
		if (!modifiers) {
			if (mapped !== undefined) {
				event.preventDefault();
				self.emit("move", mapped);
			}
		}

		// R key restarts the game
		if (!modifiers && event.which === 82) {
			self.restart.call(self, event);
		}
		if (!modifiers && event.which === 67) {
			self.copy.call(self, event);
		}
	});

	// Respond to button presses
	this.bindButtonPress(".retry-button", this.restart);
	this.bindButtonPress(".keep-playing-button", this.keepPlaying);

	// Respond to swipe events
	var touchStartClientX, touchStartClientY;
	var gameContainer = document.getElementsByClassName("game-container")[0];

	gameContainer.addEventListener(this.eventTouchstart,
	function(event) {
		if ((!window.navigator.msPointerEnabled && event.touches.length > 1) || event.targetTouches.length > 1 || self.targetIsInput(event)) {
			return; // Ignore if touching with more than 1 finger or touching input
		}

		if (window.navigator.msPointerEnabled) {
			touchStartClientX = event.pageX;
			touchStartClientY = event.pageY;
		} else {
			touchStartClientX = event.touches[0].clientX;
			touchStartClientY = event.touches[0].clientY;
		}
		event.preventDefault();
	});
	gameContainer.addEventListener(this.eventTouchmove,
	function(event) {
		event.preventDefault();
	});

	gameContainer.addEventListener(this.eventTouchend,
	function(event) {
		if ((!window.navigator.msPointerEnabled && event.touches.length > 0) || event.targetTouches.length > 0 || self.targetIsInput(event)) {
			return; // Ignore if still touching with one or more fingers or input
		}

		var touchEndClientX, touchEndClientY;
		if (window.navigator.msPointerEnabled) {
			touchEndClientX = event.pageX;
			touchEndClientY = event.pageY;
		} else {
			touchEndClientX = event.changedTouches[0].clientX;
			touchEndClientY = event.changedTouches[0].clientY;
		}

		var dx = touchEndClientX - touchStartClientX;
		var absDx = Math.abs(dx);
		var dy = touchEndClientY - touchStartClientY;
		var absDy = Math.abs(dy);
		if (Math.max(absDx, absDy) > 10) {
			// (right : left) : (down : up)
			self.emit("move", absDx > absDy ? (dx > 0 ? 1 : 3) : (dy > 0 ? 2 : 0));
		}
	});
};

KeyboardInputManager.prototype.restart = function(event) {
	event.preventDefault();
	this.emit("restart1");
};

KeyboardInputManager.prototype.copy = function() {
	event.preventDefault();
	var clipBoardContent = localStorage.step;
	window.clipboardData.setData("Text", clipBoardContent);
};

KeyboardInputManager.prototype.keepPlaying = function(event) {
	event.preventDefault();
	this.emit("keepPlaying");
};

KeyboardInputManager.prototype.bindButtonPress = function(selector, fn) {
	var button = document.querySelector(selector);
	button.addEventListener("click", fn.bind(this));
	button.addEventListener(this.eventTouchend, fn.bind(this));
};

KeyboardInputManager.prototype.targetIsInput = function(event) {
	return event.target.tagName.toLowerCase() === "input";
};

window.fakeStorage = {
	_data: {},

	moveItem: function(id, val) {
		return this._data[id] = this._data[id] + String(val);
	},

	setItem: function(id, val) {
		return this._data[id] = String(val);
	},

	getItem: function(id) {
		return this._data.hasOwnProperty(id) ? this._data[id] : undefined;
	},

	removeItem: function(id) {
		return delete this._data[id];
	},

	clear: function() {
		return this._data = {};
	}
};

function LocalStorageManager() {
	this.gameStateKey = "gameState";
	this.noticeClosedKey = "noticeClosed";

	var supported = this.localStorageSupported();
	this.storage = supported ? window.localStorage: window.fakeStorage;
}

LocalStorageManager.prototype.localStorageSupported = function() {
	var testKey = "test";
	var storage = window.localStorage;

	try {
		storage.setItem(testKey, "1");
		storage.removeItem(testKey);
		return true;
	} catch(error) {
		return false;
	}
};

// Game state getters/setters and clearing
LocalStorageManager.prototype.getGameState = function() {
	var stateJSON = this.storage.getItem(this.gameStateKey);
	return stateJSON ? JSON.parse(stateJSON) : null;
};

LocalStorageManager.prototype.setGameState = function(gameState) {
	this.storage.setItem(this.gameStateKey, JSON.stringify(gameState));
};

LocalStorageManager.prototype.clearGameState = function() {
	localStorage.scount = 0;
	localStorage.step = "";
	this.storage.removeItem(this.gameStateKey);
};

LocalStorageManager.prototype.setNoticeClosed = function(noticeClosed) {
	this.storage.setItem(this.noticeClosedKey, JSON.stringify(noticeClosed));
};

LocalStorageManager.prototype.getNoticeClosed = function() {
	return JSON.parse(this.storage.getItem(this.noticeClosedKey) || "false");
};

function Tile(position, value) {
	this.x = position.x;
	this.y = position.y;
	this.value = value || 2;
	this.previousPosition = null;
	this.mergedFrom = null; // Tracks tiles that merged together
}

Tile.prototype.updatePosition = function(position) {
	this.x = position.x;
	this.y = position.y;
};

Tile.prototype.serialize = function() {
	return {
		position: {
			x: this.x,
			y: this.y
		},
		value: this.value
	};
};
</script>
</body>
</html>